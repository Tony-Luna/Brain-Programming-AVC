# -*- coding: utf-8 -*-
"""evolutionary_process_optimized_v1.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1jq_XM-XrEtieqaQHc0df45dZ_yKoyg27
"""

import pickle
import json

from eckity.evaluators.simple_individual_evaluator import SimpleIndividualEvaluator
from eckity.algorithms.simple_evolution import SimpleEvolution
from eckity.breeders.simple_breeder import SimpleBreeder
from eckity.creators.gp_creators.ramped_hh import RampedHalfAndHalfCreator
from eckity.genetic_operators.crossovers.subtree_crossover import SubtreeCrossover
from eckity.genetic_operators.mutations.erc_mutation import ERCMutation
from eckity.genetic_operators.mutations.subtree_mutation import SubtreeMutation
from eckity.genetic_operators.selections.tournament_selection import TournamentSelection
from eckity.statistics.best_average_worst_statistics import BestAverageWorstStatistics
from eckity.subpopulation import Subpopulation
from eckity.termination_checkers.threshold_from_target_termination_checker import ThresholdFromTargetTerminationChecker

import random

class AVCEvaluator(SimpleIndividualEvaluator):
    def __init__(self, train_set, val_set, test_set, model, evo_key):
        super().__init__()

        self.train_set = train_set
        self.val_set = val_set
        self.test_set = test_set

        self.avc_model = model
        self.evo_key = evo_key


    def evaluate_individual(self, ind):
        self.avc_model.evo_func[self.evo_key] = ind

        train_acc = self.avc_model.train_classifier(self.train_set)
        val_acc, _ = self.avc_model.evaluate_classifier(self.val_set)

        print('')
        print('Train accuracy: {}%'.format(100*train_acc))
        print('Validation accuracy: {}%'.format(100*val_acc))

        return val_acc

    def evaluate_best_individual(self, algo):
        ind = algo.best_of_run_

        self.avc_model.evo_func[self.evo_key] = ind

        train_acc = self.avc_model.train_classifier(self.train_set)
        val_acc, _ = self.avc_model.evaluate_classifier(self.val_set)

        print('')
        print('Best Individual for {}: '.format(self.evo_key))
        ind.show()
        print('Train accuracy: {}%'.format(100*train_acc))
        print('Validation accuracy: {}%'.format(100*val_acc))

        return self.avc_model


def evolution_process(evaluator, pop_size, max_gen, function_set, terminal_set):
    # each node of the GP tree is either a terminal or a function
    # Initialize the evolutionary algorithm
    algo = SimpleEvolution(
        Subpopulation(creators=RampedHalfAndHalfCreator(init_depth=(2, 4),
                                                        terminal_set=terminal_set,
                                                        function_set=function_set,
                                                        bloat_weight=0.0001),
                      population_size=pop_size,
                      # user-defined fitness evaluation method
                      evaluator=evaluator,
                      # minimization problem (fitness is MAE), so higher fitness is worse
                      higher_is_better=True,
                      elitism_rate=0.05,
                      # genetic operators sequence to be applied in each generation
                      operators_sequence=[
                          SubtreeCrossover(probability=0.9, arity=2),
                          SubtreeMutation(probability=0.2, arity=1),
                          ERCMutation(probability=0.05, arity=1)
                      ],
                      selection_methods=[
                          # (selection method, selection probability) tuple
                          (TournamentSelection(tournament_size=4, higher_is_better=True), 1)
                      ]
                      ),
        breeder=SimpleBreeder(),
        max_workers=1,
        max_generation=max_gen,
        random_seed=random.random(),
        termination_checker=ThresholdFromTargetTerminationChecker(optimal=0, threshold=0.001),
        statistics=BestAverageWorstStatistics()
    )

    # evolve the generated initial population
    algo.evolve()

    # execute the best individual after the evolution process ends
    evolved_model = evaluator.evaluate_best_individual(algo)

    return evolved_model

# Function to evaluate best model after all evolutions -------------------------
def evaluate_best_avc(train_set, val_set, test_set, avc_model, evo_keys, metrics_file, save_model_file=None):
  train_acc = avc_model.train_classifier(train_set)
  val_acc, _ = avc_model.evaluate_classifier(val_set)
  test_acc, test_cm = avc_model.evaluate_classifier(test_set)

  print('')
  print('Best model summary: ')
  for key in evo_keys:
    print('--------{} Function------------'.format(key))
    avc_model.evo_func[key].show()

  print('Train accuracy: {}%'.format(100*train_acc))
  print('Validation accuracy: {}%'.format(100*val_acc))
  print('Test accuracy: {}%'.format(100*test_acc))
  
  print('Confussion Matrix - Test set: {}'.format(test_cm))

  save_data(train_acc, val_acc, test_acc, metrics_file)
  
  if save_model_file is not None:
      save_model(avc_model, save_model_file)

# Support functions ------------------------------------------------------------

def save_model(model, save_file):
  with open(save_file, 'wb') as model_file:
    pickle.dump(model, model_file)

  print('Saved Model!')

def save_data(train_acc, val_acc, test_acc, save_file):
  metrics = {'Train accuracy':train_acc,
             'Val accuracy': val_acc,
             'Test accuracy': test_acc}

  with open(save_file, 'w') as file:
     json.dump(metrics, file, indent=4)

  print('Saved metrics!')