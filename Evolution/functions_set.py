# -*- coding: utf-8 -*-
"""Functions_Set.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1OnlfYwnRwXg9P49QlYwUqrX7I6k4Iscp
"""

from skimage.color import rgb2gray
from skimage.filters import threshold_otsu, median, gaussian, laplace, sobel
from skimage.filters import gabor_kernel
from skimage.morphology import square, disk, diamond
from skimage.morphology import white_tophat, black_tophat, skeletonize
from skimage.morphology import opening, erosion, dilation, closing
from skimage.morphology import binary_erosion, binary_dilation
from skimage.filters.rank import maximum, minimum
from skimage.exposure import equalize_hist
from skimage.feature import canny
from skimage.util import img_as_ubyte

from scipy.signal import convolve2d
from scipy.ndimage import gaussian_filter
from scipy.ndimage import gaussian_filter1d
from scipy.ndimage import binary_hit_or_miss

import numpy as np
import numpy.matlib

from math import ceil, floor, pi, cos, sin, sqrt

"""# Helpers"""

from scipy.signal import convolve2d

def conv2(x, y, mode='same'):
  return np.rot90(convolve2d(np.rot90(x, 2), 
                             np.rot90(y, 2), 
                             mode=mode), 2)
  
def zero_cross_detection(image):
  z_c_image = np.zeros(image.shape)

  for i in range(0,image.shape[0]-1):
      for j in range(0,image.shape[1]-1):
          if image[i][j]>0:
              if image[i+1][j] < 0 or image[i+1][j+1] < 0 or image[i][j+1] < 0:
                  z_c_image[i,j] = 1
          elif image[i][j] < 0:
              if image[i+1][j] > 0 or image[i+1][j+1] > 0 or image[i][j+1] > 0:
                  z_c_image[i,j] = 1
  return z_c_image

def gaussian_derivative_filter(sigma, img, axis):
  tam = floor(2.5*sigma)

  x, y = np.meshgrid(np.linspace(-tam, tam, tam*2 + 1),
                     np.linspace(-tam, tam, tam*2 + 1))
  
  gauss_kernel = (1/(2*pi*sigma**2))*np.exp(-((x**2 + y**2)/(2*sigma**2)))

  gauss_kernel = gauss_kernel/np.sum(gauss_kernel)

  if axis == 0:
    gauss_deriv_kernel = (-x/sigma**2) * gauss_kernel
  elif axis == 1:
    gauss_deriv_kernel = (-y/sigma**2) * gauss_kernel

  return conv2(img, gauss_deriv_kernel)

def gaussian_filter(sigma, img):
  tam = floor(2.5*sigma)

  x, y = np.meshgrid(np.linspace(-tam, tam, tam*2 + 1),
                     np.linspace(-tam, tam, tam*2 + 1))
  
  gauss_kernel = (1/(2*pi*sigma**2))*np.exp(-((x**2 + y**2)/(2*sigma**2)))

  gauss_kernel = gauss_kernel/np.sum(gauss_kernel)

  return conv2(img, gauss_kernel)

def Gabor2(img, sx, sy, f, theta):
  sx_list = [i for i in range(-int(sx), int(sx)+1)]
  sy_list = [i for i in range(-int(sy), int(sy)+1)]

  G = np.zeros((len(sx_list), len(sy_list)), dtype=complex)

  for x in sx_list:
    for y in sy_list:
      M = np.exp(f*1j*(x*cos(theta) + y*sin(theta)))
      G[int(sx) + x, int(sy) + y] = (1/(2*pi))*np.exp(-0.5*((x/sx)**2 + (y/sy)**2))*M

  Imgabout = conv2(img, np.imag(G).astype(float))
  Regabout = conv2(img, np.real(G).astype(float))

  gabout = (np.sqrt(np.power(Imgabout, 2) + np.power(Regabout, 2)))

  return gabout

def mat2gray(img):
  min_limit = np.min(img)
  max_limit = np.max(img)

  if min_limit == max_limit:
    I = img.astype(float)
  else:
    delta = 1/(max_limit - min_limit)
    I = delta*img - min_limit*delta

  I = np.maximum(np.zeros_like(I), np.minimum(I, np.ones_like(I)))

  return I

def bwhitmiss(bw, se1, se2):
  out = np.bitwise_and(binary_erosion(bw, se1), 
                       np.bitwise_not(binary_dilation(bw, se2)))
  
  return out

# Linear normalization for images ----------------------------------------------
def linear_normalization(img):
  img_norm = np.zeros_like(img, dtype=float)

  max_img = np.max(img)
  min_img = np.min(img)

  a = (img - min_img)
  b = (max_img - min_img)
  
  a = np.nan_to_num(a)
  b = np.nan_to_num(b)

  img_norm = np.divide(a, b, out=np.zeros_like(a), where=b!=0)

  return img_norm

"""# Unary Functions

## Simple operations
"""

"""
  Función con asíntota en 0 --> -Inf

  Incrementa exponencialmente la magnitud de los 
  valores cercanos a 0.

  Aplicaciones?
    En extracción de características puede que no
    En EFI puede que si, pues estos si tienen valores muy pequenos
"""

def ip_Logarithm(img):
  return np.log(np.abs(img), 
                where=img!=0, 
                out=np.zeros_like(img))
  
def ip_Logarithm10(img):
  return np.log10(np.abs(img), 
                where=img!=0, 
                out=np.zeros_like(img))
  
def ip_Logarithm2(img):
  return np.log2(np.abs(img), 
                where=img!=0, 
                out=np.zeros_like(img))

"""
  Incrementa valores grandes

  Aplicaciones?
    En extracción de características para resaltar pixeles de valores
    altos.
"""

def ip_Exp(img):
  out = np.exp(linear_normalization(img))
  
  i = np.where(out == float("-inf"))
  j = np.where(np.isnan(out))
  k = np.where(out == float("inf"))

  out[i] = 0.
  out[j] = 0.
  out[k] = 1.

  return out

"""
  Reduce todos los valores de manera no lineal (por rangos de 0-1)

  Aplicaciones?
    Extracción de características y EFI
"""

def ip_Sqr(img):
  return np.power(linear_normalization(img), 2)

"""
  Incrementa todos los valores de manera no lineal (por rangos de 0-1)

  Aplicaciones?
    Extracción de características y EFI
"""

def ip_Sqrt(img):
  return np.sqrt(np.abs(img))

"""
  Binarización

  Aplicaciones?
    Extracción de caractrísticas
"""

def threshold(img):
  img = np.nan_to_num(img, nan=0)
  thresh = threshold_otsu(img)*np.max(img)
  output = np.where(img > thresh, img, 
                    np.zeros_like(img))

  return output


"""
  Se considera como binarización al trabajar con valores de 0-1

  Aplicaciones?
    Extracción de caractrísticas
"""

def imRound(img):
  return np.rint(img)

"""
  Amortigua a la mitad los valores en la imagen

  Aplicaciones?
    EFI posiblemente, Extracción de características no resalta nada.
"""

def ip_Half(img):
  return img*0.5

def imCeil(img):
  return np.ceil(img)

"""
  Retiene valores de 1 en imagenes de 0-1

  Aplicaciones:
    EFI, para extracción de características se pierde mucha información
"""

def imFloor(img):
  return np.floor(img)

def ip_imcomplement(img):
  return 1 - img

def ip_imabs(img):
  return np.abs(img)

"""## Image processing operations"""

def ip_histeq(img):
  return equalize_hist(img)

"""## Filters"""

def ip_Sobely(img):
  s = np.array([[1, 2, 1], 
                [0, 0, 0], 
                [-1, -2, -1]])

  return conv2(img, s.T)

def ip_Sobelx(img):
  s = np.array([[1, 2, 1], 
                [0, 0, 0], 
                [-1, -2, -1]])

  return conv2(img, s)

def ip_MinFilter(img):
  img = img_as_ubyte(img)
  Y = minimum(img, square(3))
  Y = (Y/255).astype(float)

  return Y

def ip_Median(img):
  med = median(img, square(3))

  return med

def ip_MaxFilter(img):
  img = img_as_ubyte(img)
  Y = maximum(img, square(3))
  Y = (Y/255).astype(float)

  return Y

def ip_LoG(img):
  s_img = sobel(img)

  s_img[s_img >= 0.1] = 1.
  s_img[s_img < 0.1] = 0.

  g_img = gaussian(img, 2)
  l_img = laplace(g_img)

  zero_crossing_log = zero_cross_detection(l_img)

  edges = np.multiply(s_img, zero_crossing_log)
  edges[edges > 0] = 1.

  return edges

def ip_GaussDy_15(img):
  filt_img = gaussian_derivative_filter(1.5, 
                                        img, 
                                        axis=1)

  return filt_img

def ip_GaussDy_05(img):
  filt_img = gaussian_derivative_filter(0.5, 
                                        img, 
                                        axis=1)

  return filt_img

def ip_GaussDy_2(img):
  filt_img = gaussian_derivative_filter(2, 
                                        img, 
                                        axis=1)

  return filt_img

def ip_GaussDy_1(img):
  filt_img = gaussian_derivative_filter(1, 
                                        img, 
                                        axis=1)

  return filt_img

def ip_GaussDx_15(img):
  filt_img = gaussian_derivative_filter(1.5, 
                                        img, 
                                        axis=0)

  return filt_img

def ip_GaussDx_05(img):
  filt_img = gaussian_derivative_filter(0.5, 
                                        img, 
                                        axis=0)

  return filt_img

def ip_GaussDx_2(img):
  filt_img = gaussian_derivative_filter(2, 
                                        img, 
                                        axis=0)

  return filt_img

def ip_GaussDx_1(img):
  filt_img = gaussian_derivative_filter(1, 
                                        img, 
                                        axis=0)

  return filt_img

def ip_Gauss_15(img):
  filt_img = gaussian_filter(1.5, 
                             img)
  
  return filt_img

def ip_Gauss_05(img):
  filt_img = gaussian_filter(0.5, 
                             img)
  
  return filt_img

def ip_Gauss_2(img):
  filt_img = gaussian_filter(2, 
                             img)
  
  return filt_img

def ip_Gauss_1(img):
  filt_img = gaussian_filter(1, 
                             img)
  
  return filt_img

def ip_Gabor7(img):
  filt_img = Gabor2(img, 2, 2, pi/2, pi*7/8)

  return filt_img

def ip_Gabor6(img):
  filt_img = Gabor2(img, 2, 2, pi/2, pi*6/8)

  return filt_img

def ip_Gabor5(img):
  filt_img = Gabor2(img, 2, 2, pi/2, pi*5/8)

  return filt_img

def ip_Gabor4(img):
  filt_img = Gabor2(img, 2, 2, pi/2, pi*4/8)

  return filt_img

def ip_Gabor3(img):
  filt_img = Gabor2(img, 2, 2, pi/2, pi*3/8)

  return filt_img

def ip_Gabor2(img):
  filt_img = Gabor2(img, 2, 2, pi/2, pi*2/8)

  return filt_img

def ip_Gabor1(img):
  filt_img = Gabor2(img, 2, 2, pi/2, pi*1/8)

  return filt_img

def ip_Gabor0(img):
  filt_img = Gabor2(img, 2, 2, pi/2, 0)

  return filt_img

def ip_Canny(img):
  filt_img = canny(img, sigma=sqrt(2)).astype(float)

  return filt_img

def imagen_unos(img):
  return np.ones_like(img, dtype=float)

def imabs(img):
  return np.abs(img)

"""## With numeric modifiable values"""

"""
  Ambas funciones procesan los valores de la imagen de manera no lineal
"""

def kRoot(img, k):
  return np.abs(np.power(img, 1/k))

def kPwr(img, k):
  return np.abs(np.power(img, k))

"""# Shape functions"""

def topHat(img):
  footprint = square(20)
  filt_img = white_tophat(img, footprint)

  return filt_img

def skeletonShp(img):
  img = mat2gray(img)
  img = np.nan_to_num(img, nan=0)
  thresh = threshold_otsu(img)
  binary = img > thresh
  skel_img = skeletonize(binary).astype(float)

  output = np.multiply(img, skel_img)

  return output

def perimeterShp(img):
  img = mat2gray(img)
  img = np.nan_to_num(img, nan=0)
  footprint = square(3)
  thresh = threshold_otsu(img)
  binary = img > thresh
  erosion = binary_erosion(binary, footprint)
  perimeter = np.abs(erosion.astype(float) - binary.astype(float))

  out = np.multiply(img, perimeter)

  return out

def openMph(img):
  footprint = square(20)

  output = opening(img, footprint)

  return output

def erodeSqr(img):
  footprint = square(20)

  output = erosion(img, footprint)

  return output

def erodeDsk(img):
  footprint = disk(20)

  output = erosion(img, footprint)

  return output

def erodeDmnd(img):
  footprint = diamond(20)

  output = erosion(img, footprint)

  return output

def dilateSqr(img):
  footprint = square(20)

  output = dilation(img, footprint)

  return output

def dilateDsk(img):
  footprint = disk(20)

  output = dilation(img, footprint)

  return output

def dilateDmnd(img):
  footprint = diamond(20)

  output = dilation(img, footprint)

  return output

def closeMph(img):
  footprint = square(20)

  output = closing(img, footprint)

  return output

def bottomHat(img):
  footprint = square(20)
  filt_img = black_tophat(img, footprint)

  return filt_img

def hitmissSqr(img):
  img = mat2gray(img)
  footprint_1 = square(20)
  footprint_2 = 1 - footprint_1
  img = np.nan_to_num(img, nan=0)
  thresh = threshold_otsu(img)
  binary = img > thresh

  img_h = bwhitmiss(binary, 
                    footprint_1, 
                    footprint_2).astype(float)

  output = np.multiply(img, img_h)

  return output

def hitmissDsk(img):
  img = mat2gray(img)
  footprint_1 = disk(20)
  footprint_2 = np.zeros_like(footprint_1)
  img = np.nan_to_num(img, nan=0)
  thresh = threshold_otsu(img)
  binary = img > thresh

  img_h = bwhitmiss(binary, 
                    footprint_1, 
                    footprint_2).astype(float)

  output = np.multiply(img, img_h)

  return output

def hitmissDmnd(img):
  img = mat2gray(img)
  footprint_1 = diamond(20)
  footprint_2 = np.zeros_like(footprint_1)
  img = np.nan_to_num(img, nan=0)
  thresh = threshold_otsu(img)
  binary = img > thresh

  img_h = bwhitmiss(binary, 
                    footprint_1, 
                    footprint_2).astype(float)

  output = np.multiply(img, img_h)

  return output

def openMph_5(img):
  footprint = square(5)

  output = opening(img, footprint)

  return output

def erodeSqr_5(img):
  footprint = square(5)

  output = erosion(img, footprint)

  return output

def erodeDsk_5(img):
  footprint = disk(5)

  output = erosion(img, footprint)

  return output

def erodeDmnd_5(img):
  footprint = diamond(5)

  output = erosion(img, footprint)

  return output

def dilateSqr_5(img):
  footprint = square(5)

  output = dilation(img, footprint)

  return output

def dilateDsk_5(img):
  footprint = disk(5)

  output = dilation(img, footprint)

  return output

def dilateDmnd_5(img):
  footprint = diamond(5)

  output = dilation(img, footprint)

  return output

def closeMph_5(img):
  footprint = square(5)

  output = closing(img, footprint)

  return output

def bottomHat_5(img):
  footprint = square(5)
  filt_img = black_tophat(img, footprint)

  return filt_img

def hitmissSqr_5(img):
  img = mat2gray(img)
  footprint_1 = square(5)
  footprint_2 = 1 - footprint_1
  img = np.nan_to_num(img, nan=0)
  thresh = threshold_otsu(img)
  binary = img > thresh

  img_h = bwhitmiss(binary, 
                    footprint_1, 
                    footprint_2).astype(float)

  output = np.multiply(img, img_h)

  return output

def hitmissDsk_5(img):
  img = mat2gray(img)
  footprint_1 = disk(5)
  footprint_2 = np.zeros_like(footprint_1)
  img = np.nan_to_num(img, nan=0)
  thresh = threshold_otsu(img)
  binary = img > thresh

  img_h = bwhitmiss(binary, 
                    footprint_1, 
                    footprint_2).astype(float)

  output = np.multiply(img, img_h)

  return output

def hitmissDmnd_5(img):
  img = mat2gray(img)
  footprint_1 = diamond(5)
  footprint_2 = np.zeros_like(footprint_1)
  img = np.nan_to_num(img, nan=0)
  thresh = threshold_otsu(img)
  binary = img > thresh

  img_h = bwhitmiss(binary, 
                    footprint_1, 
                    footprint_2).astype(float)

  output = np.multiply(img, img_h)

  return output

"""# Color functions"""

def RedGreenOpon(img_rgb):
  r = img_rgb[:,:,0]
  g = img_rgb[:,:,1]
  b = img_rgb[:,:,2]

  i = np.maximum(r, np.maximum(g, b))

  m1 = r-g 
  m2 = i

  rg_opp = np.divide(m1, 
                     m2, 
                     out=np.zeros_like(m1), 
                     where=m2!=0)

  return rg_opp

def BlueYellowOpon(img_rgb):
  r = img_rgb[:,:,0]
  g = img_rgb[:,:,1]
  b = img_rgb[:,:,2]

  i = np.maximum(r, np.maximum(g, b))

  m1 = b - np.minimum(r,g)
  m2 = i

  by_opp = np.divide(m1, 
                     m2, 
                     out=np.zeros_like(m1), 
                     where=m2!=0)

  return by_opp

"""# Binary functions"""

def supremum(x,y):
  return np.maximum(x, y)

def ip_imsubtract(x,y):
  return np.abs(np.subtract(x,y))

def ip_immultiply(x,y):
  return np.multiply(x,y)

def ip_imdivide(x,y):
  output = np.divide(x, 
                     y, 
                     out=np.copy(x), 
                     where=y!=0)
  
  return output

def ip_imadd(x,y):
  return np.add(x,y)

def ip_imabsadd(x,y):
  return np.add(np.abs(x), np.abs(y))

def infimum(x,y):
  return np.minimum(x, y)

def ip_oppon(x,y,z):
  subs = ip_imsubtract(x,y)
  output = ip_imdivide(subs, z)

  return output